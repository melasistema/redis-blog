// seed-redis.ts
import { createClient } from 'redis';
import * as dotenv from 'dotenv';

dotenv.config(); // Load environment variables from .env file

// Simple slugify function (copied from API route for consistency)
function slugify(text: string): string {
    return text
        .toString()
        .toLowerCase()
        .replace(/\s+/g, '-') // Replace spaces with -
        .replace(/[^\w\-]+/g, '') // Remove all non-word chars
        .replace(/\-\-+/g, '-') // Replace multiple - with one -
        .replace(/^-+/, '') // Trim - from start
        .replace(/-+$/, ''); // Trim - from end
}

async function seedRedis() {
    const redisUrl = process.env.NUXT_REDIS_URL || 'redis://localhost:6380';
    const redis = createClient({ url: redisUrl });

    redis.on('error', (err) => console.error('Redis Client Error', err));

    try {
        await redis.connect();
        console.log('Connected to Redis');

        // Clear existing data for a fresh seed
        await redis.flushAll();
        console.log('Cleared all existing Redis data.');

        const examplePosts = [
            {
                title: 'Welcome to Your New Redis Nuxt Blog!',
                content: `
# Welcome to Your New Blog!

This is your first post, generated by the seed script. This boilerplate is a powerful starting point for building a high-performance, deeply customizable blog with **Nuxt.js** and **Redis Stack**.

## Core Philosophy

The goal of this project is to provide a solid foundation that is both easy to use and easy to extend. Here are the core principles:

- **Performance First:** Built with Nuxt for server-side rendering and Redis for ultra-fast data access.
- **Deeply Customizable:** Almost every aspect of the blog, from fonts and colors to features like pagination, can be configured from a single file.
- **Developer-Friendly:** A clean, modern tech stack with Docker for a consistent environment and a CLI for managing posts.

## What's Included?

*   üöÄ Nuxt.js 3 Frontend & API
*   ‚ö° Redis Stack as the Primary Database (using RedisJSON)
*   üé® Customizable Theming via \`config/blog.config.ts\`
*   üìù **Markdown Support** for writing posts.
*   ‚öôÔ∏è Feature Toggles for pagination, post navigation, and excerpts.
*   üì¶ A fully Dockerized environment.

Feel free to delete this post and start writing your own amazing content!
                `,
                author: 'Boilerplate Bot',
                tags: ['welcome', 'getting-started', 'nuxt', 'redis'],
            },
            {
                title: 'Deeply Customize Your Blog in Minutes',
                content: `
# Customize Your Blog's Look and Feel

One of the key features of this boilerplate is its deep customizability, managed from a single file: \`config/blog.config.ts\`.

## Changing Fonts and Colors

You can define your blog's entire visual identity by modifying the \`typography\` and \`colors\` objects.

\`\`\`typescript
// config/blog.config.ts
export const defaultBlogConfig = {
  // ...
  typography: {
    body: { fontFamily: 'Inter', weights: '400..700', italic: true },
    h1: { fontFamily: 'Poppins', weights: '700' },
    // ...
  },
  colors: {
    primary: '#ff5733',
    secondary: '#5c6ac4',
    text: '#333333',
    background: '#f8f9fa',
  },
};
\`\`\`

## Toggling Features

Easily enable or disable major features like pagination, post navigation, or the new post excerpts.

\`\`\`typescript
// config/blog.config.ts
export const defaultBlogConfig = {
    // ...
    pagination: {
        enabled: true,
        postsPerPage: 5,
    },
    postNavigation: {
        enabled: true,
    },
    postExcerpt: {
        enabled: true,
        maxLength: 200,
    },
    // ...
};
\`\`\`

Simply update the file, and your changes will be reflected instantly in your development environment after a server restart.
                `,
                author: 'Boilerplate Bot',
                tags: ['customization', 'theming', 'config', 'tutorial'],
            },
            {
                title: 'Writing Posts with Markdown',
                content: `
# Mastering Content with Markdown

This blog fully supports writing posts in Markdown, allowing you to create rich, formatted content with ease.

## Creating a Post

To create a new post, run the following command in your terminal:

\`\`\`bash
npm run new-post
\`\`\`

You will be prompted for a title, tags, and author. For the content, you can write multi-line Markdown. When you're finished, type **(end)** on a new line to save the post.

## Markdown Examples

Here‚Äôs a quick demonstration of what you can do:

### Text Formatting

You can use *italics*, **bold**, and \`inline code\`.

### Lists

- Unordered List Item 1
- Unordered List Item 2

1.  Ordered List Item 1
2.  Ordered List Item 2

### Code Blocks

You can also include syntax-highlighted code blocks:

\`\`\`javascript
// Example of a JavaScript function
function greet(name) {
  console.log(\`Hello, \${name}!\`);
}
\`\`\`

This makes it easy to write technical articles and tutorials.
                `,
                author: 'Boilerplate Bot',
                tags: ['markdown', 'writing', 'cli', 'tutorial'],
            },
            {
                title: 'Under the Hood: Architecture Overview',
                content: `
# The Redis & Nuxt Architecture

Ever wondered how this boilerplate works? Here‚Äôs a high-level look at the architecture.

## The Stack

- **Nuxt.js 3:** Acts as both the frontend framework (Vue.js) and the backend API server (using Nitro).
- **Redis Stack:** Serves as the primary database.
  - **RedisJSON:** Stores each post as a JSON document, allowing for flexible and structured data.
  - **Redis Sorted Sets:** Used to maintain a chronological index of posts (\`posts:by_date\`), making timeline queries extremely fast.
- **Docker:** Containerizes the entire application for a consistent and reproducible environment.

## Data Flow

1.  A user requests a page (e.g., the homepage).
2.  The Nuxt frontend calls an internal API route (e.g., \`/api/posts\`).
3.  The API route in \`/server/api/\` connects to Redis.
4.  It fetches the post keys from the \`posts:by_date\` sorted set.
5.  It then retrieves the full post data for each key using RedisJSON commands.
6.  The data is returned to the frontend, rendered into HTML, and served to the user.

This architecture is designed for speed, scalability, and ease of development.
                `,
                author: 'Boilerplate Bot',
                tags: ['architecture', 'technical', 'nuxt', 'redis', 'redisjson'],
            },
             {
                title: 'Deploying Your Blog to Production',
                content: `
# From Development to Production

Taking your blog live requires a few key steps. This guide provides a general overview.

## Environment Variables

Before deploying, ensure you have a \`.env\` file for your production environment. Copy \`.env.example\` and fill in the values for your production Redis instance and domain.

## Using Docker Compose for Production

This boilerplate includes a production-ready Docker Compose file.

\`\`\`bash
docker compose -f docker-compose.prod.yml up -d --build
\`\`\`

This command builds the Nuxt application in production mode and runs it in a container, connecting it to your Redis instance.

## Key Considerations

- **Hosting:** You'll need a server or service that can run Docker containers (e.g., DigitalOcean, AWS EC2, or a similar VPS).
- **Redis Provider:** While you can host Redis yourself, consider using a managed service like Redis Enterprise Cloud for scalability and reliability.
- **CI/CD:** For automated deployments, set up a CI/CD pipeline (e.g., using GitHub Actions) to automatically build and deploy your application whenever you push changes.
                `,
                author: 'Boilerplate Bot',
                tags: ['deployment', 'production', 'docker', 'devops'],
            },
        ];

        for (const postData of examplePosts) {
            const id = Math.random().toString(36).substring(2, 12);
            const slug = slugify(postData.title);

            // Generate random creation dates (within last 30 days)
            const createdAt = new Date(
                Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000
            ).toISOString();

            const post = {
                id,
                slug,
                title: postData.title,
                content: postData.content,
                author: postData.author,
                tags: postData.tags,
                createdAt,
                published: true,
            };

            const postKey = `post:${id}`;
            const createdAtTimestamp = new Date(post.createdAt).getTime();

            const multi = redis.multi();
            multi.json.set(postKey, '$', post as any);
            multi.zAdd('posts:by_date', {
                score: createdAtTimestamp,
                value: postKey,
            });
            multi.hSet('slugs', slug, postKey);

            // Add tags to global and tag-specific SETs
            if (post.tags?.length) {
                for (const tag of post.tags) {
                    multi.sAdd('tags:all', tag);
                    multi.sAdd(`tag:${slugify(tag)}`, postKey);
                }
            }

            await multi.exec();
            console.log(`Seeded post: "${post.title}" with key "${postKey}"`);
        }

        console.log('Redis seeding complete!');
        await redis.save();
        console.log('Redis data saved to disk.');
    } catch (error) {
        console.error('Failed to seed Redis:', error);
    } finally {
        await redis.disconnect();
        console.log('Disconnected from Redis');
    }
}

seedRedis();
